Parsed test spec with 3 sessions

starting permutation: controller_init_locks controller_toggle_on_wait_condition controller_show s1_upsert s2_upsert controller_show controller_toggle_off_wait_condition controller_unlock_index_constraint_check_lock_s1 controller_unlock_index_constraint_check_lock_s2 controller_show controller_unlock_index_insert_lock_s2 controller_show controller_unlock_index_insert_lock_s1 controller_show
step controller_init_locks: SELECT pg_advisory_lock(1, 2); SELECT pg_advisory_lock(1, 3); SELECT pg_advisory_lock(2, 2); SELECT pg_advisory_lock(2, 3);
pg_advisory_lock

               
pg_advisory_lock

               
pg_advisory_lock

               
pg_advisory_lock

               
step controller_toggle_on_wait_condition: SELECT pg_advisory_lock(1, 1); SELECT pg_advisory_lock(2, 1);
pg_advisory_lock

               
pg_advisory_lock

               
step controller_show: SELECT * FROM upserttest;
key            data           

s1: NOTICE:  blurt_and_lock() called for k1
s1: NOTICE:  acquiring advisory lock CHECK_INDEX_CONSTRAINTS_LOCK
step s1_upsert: INSERT INTO upserttest(key, data) VALUES('k1', 'inserted s1') ON CONFLICT (blurt_and_lock(key)) DO UPDATE SET data = upserttest.data || ' with conflict update s1'; <waiting ...>
s2: NOTICE:  blurt_and_lock() called for k1
s2: NOTICE:  acquiring advisory lock CHECK_INDEX_CONSTRAINTS_LOCK
step s2_upsert: INSERT INTO upserttest(key, data) VALUES('k1', 'inserted s2') ON CONFLICT (blurt_and_lock(key)) DO UPDATE SET data = upserttest.data || ' with conflict update s2'; <waiting ...>
step controller_show: SELECT * FROM upserttest;
key            data           

step controller_toggle_off_wait_condition: SELECT pg_advisory_unlock(1, 1); SELECT pg_advisory_unlock(2, 1);
pg_advisory_unlock

t              
pg_advisory_unlock

t              
step controller_unlock_index_constraint_check_lock_s1: SELECT pg_advisory_unlock(1, 3);
pg_advisory_unlock

t              
s1: NOTICE:  blurt_and_lock() called for k1
s1: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
step controller_unlock_index_constraint_check_lock_s2: SELECT pg_advisory_unlock(2, 3);
pg_advisory_unlock

t              
s2: NOTICE:  blurt_and_lock() called for k1
s2: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
step controller_show: SELECT * FROM upserttest;
key            data           

step controller_unlock_index_insert_lock_s2: SELECT pg_advisory_unlock(2, 2);
pg_advisory_unlock

t              
step s2_upsert: <... completed>
step controller_show: SELECT * FROM upserttest;
key            data           

k1             inserted s2    
step controller_unlock_index_insert_lock_s1: SELECT pg_advisory_unlock(1, 2);
pg_advisory_unlock

t              
s1: NOTICE:  blurt_and_lock() called for k1
s1: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
s1: NOTICE:  blurt_and_lock() called for k1
s1: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
step s1_upsert: <... completed>
step controller_show: SELECT * FROM upserttest;
key            data           

k1             inserted s2 with conflict update s1

starting permutation: controller_init_locks controller_toggle_on_wait_condition controller_show s1_upsert s2_upsert controller_show controller_toggle_off_wait_condition controller_unlock_index_constraint_check_lock_s1 controller_unlock_index_constraint_check_lock_s2 controller_show controller_unlock_index_insert_lock_s1 controller_show controller_unlock_index_insert_lock_s2 controller_show
step controller_init_locks: SELECT pg_advisory_lock(1, 2); SELECT pg_advisory_lock(1, 3); SELECT pg_advisory_lock(2, 2); SELECT pg_advisory_lock(2, 3);
pg_advisory_lock

               
pg_advisory_lock

               
pg_advisory_lock

               
pg_advisory_lock

               
step controller_toggle_on_wait_condition: SELECT pg_advisory_lock(1, 1); SELECT pg_advisory_lock(2, 1);
pg_advisory_lock

               
pg_advisory_lock

               
step controller_show: SELECT * FROM upserttest;
key            data           

s1: NOTICE:  blurt_and_lock() called for k1
s1: NOTICE:  acquiring advisory lock CHECK_INDEX_CONSTRAINTS_LOCK
step s1_upsert: INSERT INTO upserttest(key, data) VALUES('k1', 'inserted s1') ON CONFLICT (blurt_and_lock(key)) DO UPDATE SET data = upserttest.data || ' with conflict update s1'; <waiting ...>
s2: NOTICE:  blurt_and_lock() called for k1
s2: NOTICE:  acquiring advisory lock CHECK_INDEX_CONSTRAINTS_LOCK
step s2_upsert: INSERT INTO upserttest(key, data) VALUES('k1', 'inserted s2') ON CONFLICT (blurt_and_lock(key)) DO UPDATE SET data = upserttest.data || ' with conflict update s2'; <waiting ...>
step controller_show: SELECT * FROM upserttest;
key            data           

step controller_toggle_off_wait_condition: SELECT pg_advisory_unlock(1, 1); SELECT pg_advisory_unlock(2, 1);
pg_advisory_unlock

t              
pg_advisory_unlock

t              
step controller_unlock_index_constraint_check_lock_s1: SELECT pg_advisory_unlock(1, 3);
pg_advisory_unlock

t              
s1: NOTICE:  blurt_and_lock() called for k1
s1: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
step controller_unlock_index_constraint_check_lock_s2: SELECT pg_advisory_unlock(2, 3);
pg_advisory_unlock

t              
s2: NOTICE:  blurt_and_lock() called for k1
s2: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
step controller_show: SELECT * FROM upserttest;
key            data           

step controller_unlock_index_insert_lock_s1: SELECT pg_advisory_unlock(1, 2);
pg_advisory_unlock

t              
step s1_upsert: <... completed>
step controller_show: SELECT * FROM upserttest;
key            data           

k1             inserted s1    
step controller_unlock_index_insert_lock_s2: SELECT pg_advisory_unlock(2, 2);
pg_advisory_unlock

t              
s2: NOTICE:  blurt_and_lock() called for k1
s2: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
s2: NOTICE:  blurt_and_lock() called for k1
s2: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
step s2_upsert: <... completed>
step controller_show: SELECT * FROM upserttest;
key            data           

k1             inserted s1 with conflict update s2

starting permutation: controller_init_locks controller_toggle_on_wait_condition controller_show s1_insert_toast s2_insert_toast controller_show controller_toggle_off_wait_condition controller_unlock_index_constraint_check_lock_s1 controller_unlock_index_constraint_check_lock_s2 controller_show controller_unlock_index_insert_lock_s1 controller_show_count controller_unlock_index_insert_lock_s2 controller_show_count
step controller_init_locks: SELECT pg_advisory_lock(1, 2); SELECT pg_advisory_lock(1, 3); SELECT pg_advisory_lock(2, 2); SELECT pg_advisory_lock(2, 3);
pg_advisory_lock

               
pg_advisory_lock

               
pg_advisory_lock

               
pg_advisory_lock

               
step controller_toggle_on_wait_condition: SELECT pg_advisory_lock(1, 1); SELECT pg_advisory_lock(2, 1);
pg_advisory_lock

               
pg_advisory_lock

               
step controller_show: SELECT * FROM upserttest;
key            data           

s1: NOTICE:  blurt_and_lock() called for k2
s1: NOTICE:  acquiring advisory lock CHECK_INDEX_CONSTRAINTS_LOCK
step s1_insert_toast: INSERT INTO upserttest VALUES('k2', ctoast_large_val()) ON CONFLICT DO NOTHING; <waiting ...>
s2: NOTICE:  blurt_and_lock() called for k2
s2: NOTICE:  acquiring advisory lock CHECK_INDEX_CONSTRAINTS_LOCK
step s2_insert_toast: INSERT INTO upserttest VALUES('k2', ctoast_large_val()) ON CONFLICT DO NOTHING; <waiting ...>
step controller_show: SELECT * FROM upserttest;
key            data           

step controller_toggle_off_wait_condition: SELECT pg_advisory_unlock(1, 1); SELECT pg_advisory_unlock(2, 1);
pg_advisory_unlock

t              
pg_advisory_unlock

t              
step controller_unlock_index_constraint_check_lock_s1: SELECT pg_advisory_unlock(1, 3);
pg_advisory_unlock

t              
s1: NOTICE:  blurt_and_lock() called for k2
s1: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
step controller_unlock_index_constraint_check_lock_s2: SELECT pg_advisory_unlock(2, 3);
pg_advisory_unlock

t              
s2: NOTICE:  blurt_and_lock() called for k2
s2: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
step controller_show: SELECT * FROM upserttest;
key            data           

step controller_unlock_index_insert_lock_s1: SELECT pg_advisory_unlock(1, 2);
pg_advisory_unlock

t              
step s1_insert_toast: <... completed>
step controller_show_count: SELECT COUNT(*) FROM upserttest;
count          

1              
step controller_unlock_index_insert_lock_s2: SELECT pg_advisory_unlock(2, 2);
pg_advisory_unlock

t              
s2: NOTICE:  blurt_and_lock() called for k2
s2: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
s2: NOTICE:  blurt_and_lock() called for k2
s2: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
step s2_insert_toast: <... completed>
step controller_show_count: SELECT COUNT(*) FROM upserttest;
count          

1              

starting permutation: controller_init_locks controller_toggle_on_wait_condition controller_show s1_begin s2_begin s1_upsert s2_upsert controller_show controller_toggle_off_wait_condition controller_unlock_index_constraint_check_lock_s1 controller_unlock_index_constraint_check_lock_s2 controller_show controller_unlock_index_insert_lock_s1 controller_show controller_unlock_index_insert_lock_s2 controller_show s1_commit controller_show s2_commit controller_show
step controller_init_locks: SELECT pg_advisory_lock(1, 2); SELECT pg_advisory_lock(1, 3); SELECT pg_advisory_lock(2, 2); SELECT pg_advisory_lock(2, 3);
pg_advisory_lock

               
pg_advisory_lock

               
pg_advisory_lock

               
pg_advisory_lock

               
step controller_toggle_on_wait_condition: SELECT pg_advisory_lock(1, 1); SELECT pg_advisory_lock(2, 1);
pg_advisory_lock

               
pg_advisory_lock

               
step controller_show: SELECT * FROM upserttest;
key            data           

step s1_begin: BEGIN;
step s2_begin: BEGIN;
s1: NOTICE:  blurt_and_lock() called for k1
s1: NOTICE:  acquiring advisory lock CHECK_INDEX_CONSTRAINTS_LOCK
step s1_upsert: INSERT INTO upserttest(key, data) VALUES('k1', 'inserted s1') ON CONFLICT (blurt_and_lock(key)) DO UPDATE SET data = upserttest.data || ' with conflict update s1'; <waiting ...>
s2: NOTICE:  blurt_and_lock() called for k1
s2: NOTICE:  acquiring advisory lock CHECK_INDEX_CONSTRAINTS_LOCK
step s2_upsert: INSERT INTO upserttest(key, data) VALUES('k1', 'inserted s2') ON CONFLICT (blurt_and_lock(key)) DO UPDATE SET data = upserttest.data || ' with conflict update s2'; <waiting ...>
step controller_show: SELECT * FROM upserttest;
key            data           

step controller_toggle_off_wait_condition: SELECT pg_advisory_unlock(1, 1); SELECT pg_advisory_unlock(2, 1);
pg_advisory_unlock

t              
pg_advisory_unlock

t              
step controller_unlock_index_constraint_check_lock_s1: SELECT pg_advisory_unlock(1, 3);
pg_advisory_unlock

t              
s1: NOTICE:  blurt_and_lock() called for k1
s1: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
step controller_unlock_index_constraint_check_lock_s2: SELECT pg_advisory_unlock(2, 3);
pg_advisory_unlock

t              
s2: NOTICE:  blurt_and_lock() called for k1
s2: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
step controller_show: SELECT * FROM upserttest;
key            data           

step controller_unlock_index_insert_lock_s1: SELECT pg_advisory_unlock(1, 2);
pg_advisory_unlock

t              
step s1_upsert: <... completed>
step controller_show: SELECT * FROM upserttest;
key            data           

step controller_unlock_index_insert_lock_s2: SELECT pg_advisory_unlock(2, 2);
pg_advisory_unlock

t              
s2: NOTICE:  blurt_and_lock() called for k1
s2: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
s2: NOTICE:  blurt_and_lock() called for k1
s2: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
step controller_show: SELECT * FROM upserttest;
key            data           

step s1_commit: COMMIT;
s2: NOTICE:  blurt_and_lock() called for k1
s2: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
step s2_upsert: <... completed>
step controller_show: SELECT * FROM upserttest;
key            data           

k1             inserted s1    
step s2_commit: COMMIT;
step controller_show: SELECT * FROM upserttest;
key            data           

k1             inserted s1 with conflict update s2

starting permutation: s1_create_non_unique_index s1_confirm_index_order controller_init_locks controller_toggle_on_wait_condition controller_show s1_upsert s2_upsert controller_show controller_toggle_off_wait_condition controller_unlock_index_constraint_check_lock_s1 controller_unlock_index_constraint_check_lock_s2 controller_show controller_lock_2_4 controller_unlock_index_insert_lock_s2 controller_show controller_unlock_index_insert_lock_s1 controller_print_speculative_locks controller_unlock_2_4 controller_show
step s1_create_non_unique_index: CREATE INDEX upserttest_key_idx ON upserttest((blurt_and_lock2(key)));
step s1_confirm_index_order: SELECT 'upserttest_key_uniq_idx'::regclass::int8 < 'upserttest_key_idx'::regclass::int8;
?column?       

t              
step controller_init_locks: SELECT pg_advisory_lock(1, 2); SELECT pg_advisory_lock(1, 3); SELECT pg_advisory_lock(2, 2); SELECT pg_advisory_lock(2, 3);
pg_advisory_lock

               
pg_advisory_lock

               
pg_advisory_lock

               
pg_advisory_lock

               
step controller_toggle_on_wait_condition: SELECT pg_advisory_lock(1, 1); SELECT pg_advisory_lock(2, 1);
pg_advisory_lock

               
pg_advisory_lock

               
step controller_show: SELECT * FROM upserttest;
key            data           

s1: NOTICE:  blurt_and_lock() called for k1
s1: NOTICE:  acquiring advisory lock CHECK_INDEX_CONSTRAINTS_LOCK
step s1_upsert: INSERT INTO upserttest(key, data) VALUES('k1', 'inserted s1') ON CONFLICT (blurt_and_lock(key)) DO UPDATE SET data = upserttest.data || ' with conflict update s1'; <waiting ...>
s2: NOTICE:  blurt_and_lock() called for k1
s2: NOTICE:  acquiring advisory lock CHECK_INDEX_CONSTRAINTS_LOCK
step s2_upsert: INSERT INTO upserttest(key, data) VALUES('k1', 'inserted s2') ON CONFLICT (blurt_and_lock(key)) DO UPDATE SET data = upserttest.data || ' with conflict update s2'; <waiting ...>
step controller_show: SELECT * FROM upserttest;
key            data           

step controller_toggle_off_wait_condition: SELECT pg_advisory_unlock(1, 1); SELECT pg_advisory_unlock(2, 1);
pg_advisory_unlock

t              
pg_advisory_unlock

t              
step controller_unlock_index_constraint_check_lock_s1: SELECT pg_advisory_unlock(1, 3);
pg_advisory_unlock

t              
s1: NOTICE:  blurt_and_lock() called for k1
s1: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
step controller_unlock_index_constraint_check_lock_s2: SELECT pg_advisory_unlock(2, 3);
pg_advisory_unlock

t              
s2: NOTICE:  blurt_and_lock() called for k1
s2: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
step controller_show: SELECT * FROM upserttest;
key            data           

step controller_lock_2_4: SELECT pg_advisory_lock(2, 4);
pg_advisory_lock

               
step controller_unlock_index_insert_lock_s2: SELECT pg_advisory_unlock(2, 2);
pg_advisory_unlock

t              
s2: NOTICE:  blurt_and_lock2() called for k1
s2: NOTICE:  acquiring advisory lock on 4
step controller_show: SELECT * FROM upserttest;
key            data           

step controller_unlock_index_insert_lock_s1: SELECT pg_advisory_unlock(1, 2);
pg_advisory_unlock

t              
s1: NOTICE:  blurt_and_lock2() called for k1
s1: NOTICE:  acquiring advisory lock on 4
s1: NOTICE:  blurt_and_lock() called for k1
s1: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
s1: NOTICE:  blurt_and_lock() called for k1
s1: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
step controller_print_speculative_locks: SELECT locktype, mode, granted FROM pg_locks WHERE locktype='speculative token' ORDER BY granted;
locktype       mode           granted        

speculative tokenShareLock      f              
speculative tokenExclusiveLock  t              
step controller_unlock_2_4: SELECT pg_advisory_unlock(2, 4);
pg_advisory_unlock

t              
s1: NOTICE:  blurt_and_lock() called for k1
s1: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
s1: NOTICE:  blurt_and_lock() called for k1
s1: NOTICE:  acquiring advisory lock WAIT_ON_INDEX_INSERT_LOCK
step s1_upsert: <... completed>
step s2_upsert: <... completed>
step controller_show: SELECT * FROM upserttest;
key            data           

k1             inserted s2 with conflict update s1
